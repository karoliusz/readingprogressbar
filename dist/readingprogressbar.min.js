var ReadingProgressBar=function(l,V,n,i){"use strict";const w={contentContainerClassName:"blogPost",cssClass:"readingProgressBar",throttleTimeMs:0},p={progressBarElement:"readingProgressBar",trackElement:"readingProgressBar__track"};var C=Object.defineProperty,P=Object.defineProperties,f=Object.getOwnPropertyDescriptors,d=Object.getOwnPropertySymbols,_=Object.prototype.hasOwnProperty,T=Object.prototype.propertyIsEnumerable,g=(s,t,e)=>t in s?C(s,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):s[t]=e,B=(s,t)=>{for(var e in t||(t={}))_.call(t,e)&&g(s,e,t[e]);if(d)for(var e of d(t))T.call(t,e)&&g(s,e,t[e]);return s},k=(s,t)=>P(s,f(t));class b{constructor(t,e=[]){this.scroll$=null,this.resize$=null,this.activeContainer$=null,this.lastActiveContainer$=null,this.viewportHeight=null,this.trackedContainers=new Set;let r=null;this.updateViewportHeight(),e&&(this.addTrackedContainers(e),r=this.getActiveContainer()),this.viewportChange$=new n.BehaviorSubject({activeContainerId:r?r.id:null,scrollPercentage:r?this.calculateScrollPercentage(r):0}),this.scroll$=n.fromEvent(window,"scroll"),this.resize$=n.fromEvent(window,"resize").pipe(i.debounceTime(300),i.tap(()=>this.updateViewportHeight())),this.activeContainer$=n.merge(this.scroll$,this.resize$).pipe(i.throttleTime(t,null,{trailing:!0,leading:!1}),i.map(()=>this.getActiveContainer())),this.lastActiveContainer$=this.activeContainer$.pipe(i.filter(o=>!!o),i.distinctUntilKeyChanged("id")),n.combineLatest([this.activeContainer$,this.lastActiveContainer$]).pipe(i.map(o=>this.getViewportState(...o))).subscribe(o=>this.viewportChange$.next(o))}addTrackedContainer(t){const e=k(B({},t),{position:this.getContainerPosition(t.element)});return this.trackedContainers.add(e),Array.from(this.trackedContainers)}addTrackedContainers(t){return t.forEach(e=>this.addTrackedContainer(e)),Array.from(this.trackedContainers)}removeTrackedContainer(t){const e=this.trackedContainers,r=Array.from(e).find(({id:o})=>o===t);return r?this.trackedContainers.delete(r):!1}clearTrackedContainers(){this.trackedContainers.clear()}getActiveContainer(){return Array.from(this.trackedContainers).find(e=>this.isActive(e))}getViewportState(t,e){let r=t?this.calculateScrollPercentage(t):0;return e&&!t&&(r=this.scrolledPast(e)?100:0),{activeContainerId:t?t.id:null,scrollPercentage:r}}calculateScrollPercentage(t){const r=this.getScrollY()+this.viewportHeight,o=this.isActive(t),a=t.position.top<this.viewportHeight;if(o&&a){const c=t.position.bottom-this.viewportHeight,h=c-(t.position.bottom-r);return Math.round(h/c*1e3)/10}else if(o){const c=t.position.bottom-t.position.top,h=t.position.bottom-r,E=c-h;return Math.round(E/c*1e3)/10}return null}isActive({position:t}){const r=this.getScrollY()+this.viewportHeight,o=t.top>r,a=t.bottom>r;return!o&&a}scrolledPast(t){const r=this.getScrollY()+this.viewportHeight;return t.position.bottom<r}getContainerPosition(t){const e=t.getBoundingClientRect(),r=this.getScrollY();return{top:e.top+r,bottom:e.bottom+r}}updateViewportHeight(){const t=document.documentElement;this.viewportHeight=t.clientHeight}getScrollY(){return window.scrollY}}class S{constructor(t,e){this.element=t,this.options=e,this.value=0,this.initialize()}setStatePercentage(t){let e=t;t>100?e=100:e<0&&(e=0),this.applyState(e)}dispose(){this.progressBarTrack.remove(),this.progressBarTrack=null,this.element.classList.remove(p.progressBarElement),this.options.cssClass&&this.element.classList.remove(this.options.cssClass),this.element=null}applyState(t){this.value=t,requestAnimationFrame(()=>{this.progressBarTrack.style.width=`${t}%`})}initialize(){const t=document.createElement("div");t.classList.add(p.trackElement),this.element.classList.add(this.options.cssClass),this.element.classList.add(p.progressBarElement),this.element.appendChild(t),this.progressBarTrack=t}}var y=Object.defineProperty,m=Object.getOwnPropertySymbols,O=Object.prototype.hasOwnProperty,$=Object.prototype.propertyIsEnumerable,u=(s,t,e)=>t in s?y(s,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):s[t]=e,v=(s,t)=>{for(var e in t||(t={}))O.call(t,e)&&u(s,e,t[e]);if(m)for(var e of m(t))$.call(t,e)&&u(s,e,t[e]);return s};class A{constructor(t,e={}){this.options=v(v({},w),e),this.progressBar=new S(t,this.options),this.viewport=new b(this.options.throttleTimeMs,this.getTrackedContainers(this.options.contentContainerClassName)),this.reset(),this.viewport.viewportChange$.subscribe(({scrollPercentage:r})=>{this.progressBar.setStatePercentage(r)})}reset(){this.redetectContentContainers()}redetectContentContainers(){const{contentContainerClassName:t}=this.options;this.viewport.addTrackedContainers(this.getTrackedContainers(t))}getTrackedContainers(t){const e=document.getElementsByClassName(t);return Array.from(e).map((o,a)=>({id:a,element:o}))}}return l.ReadingProgressBar=A,Object.defineProperty(l,"__esModule",{value:!0}),l}({},null,rxjs,operators);
//# sourceMappingURL=readingprogressbar.min.js.map
